# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

*MongoDB предоставляет два средства для завершения запущенных операций: maxTimeMS() и db.killOp().*  

*maxTimeMS() - это метод, который устанавливает лимит времени для операции. Ставится непосредственно на операции.*

*db.killOp()останавливает операцию на следующем прерывании по ID операции.*

https://www.mongodb.com/docs/manual/tutorial/terminate-running-operations/

*В данном случае найти ID операции, используя $currentOp, и остановить ее:*

```
 db.killOp(<opId>)
```

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

*Как вариант  добавить maxTimeMS поле в командный документ, чтобы установить ограничение по времени в 45 миллисекунд для операции:
```
db.runCommand( { distinct: "****",
                 key: "***",
                 maxTimeMS: 45 } )
```
Операции, которые достигают maxTimeMS, вернут MaxTimeMSExpired ошибку.



## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

*В росте количества истекших ключей в единицу времени.*

Redis удаляет ключи с истекшим сроком действия двумя способами:

- *Ленивый способ -  Удаляются ключи с истекшим сроком действия, когда он запрашивается командой, но оказывается, что срок его действия уже истек.*

- *Активный способ - Удаляются ключи каждые 100 миллисекунд. Цикл истечения запускается каждые 100 миллисекунд (10 раз в секунду) и будут выполнять следующие действия:*

*Пробные ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOPключи, вытесняющие все ключи с истекшим сроком действия.*



 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

- *Исключить проблемы подключения к сети*

- *попробовать увеличить net_read_timeout значение по умолчанию с 30 секунд до 60 секунд или дольше, для завершения передачи данных.*

- *используя SHOW GLOBAL STATUS LIKE 'Aborted_connects',  определить является ли connect_timeout значение проблемой. *

- *Для передачи больших BLOB данных можно попробовать увеличить параметр max_allowed_packet на сервере (по умолчанию 64Mb для версии 8). Максимально 1Gb.*


## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

*Скорее всего нехватка памяти*

*Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.*

*Решением может быть увеличение свопа, изменение настроек  shared_buffers, work_mem, и hash_mem_multiplier в строну уменьшения. А так же уменьшение max_connections для уменьшения количества одновременных подключений и как следствие - уменьшение потребления памяти.*

*Так же возможно изменение настроек oom-killer. Установка sysctl -w vm.overcommit_memory=2 заставит ядро не разрешать выделять память для процессов с избытком. Значительно снижая вероятность, но не гарантируя сохранность процессов от окончания oom-killer. Так же, как экстримальный вариант можно совсем отключить oom-killer, но это черевато падением ОС.*

